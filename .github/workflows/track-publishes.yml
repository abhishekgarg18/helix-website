name: Track Publishes
on:
  schedule:
    - cron: "0/5 * * * *"
  workflow_dispatch:


permissions:
  actions: read # required to access workflow runs
  contents: write # required to access the repository, for the dispatch event

jobs:
  check-last-run:
    runs-on: ubuntu-latest
    outputs:
      workflow-id: ${{ steps.workflow-id.outputs.WORKFLOW_ID }}
      last-run-iso: ${{ steps.last-run.outputs.LAST_CREATED_AT_ISO }} # ISO 8601
      last-run-unix: ${{ steps.last-run.outputs.LAST_CREATED_AT_UNIX }} # Unix timestamp
      branch-name: ${{ steps.branch-name.outputs.BRANCH_NAME }}
    steps:
      - name: Get branch name
        id: branch-name
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ ${GITHUB_EVENT_NAME} == "pull_request" ]]
          then
             echo "BRANCH_NAME=${GITHUB_HEAD_REF}" >> $GITHUB_OUTPUT
          else
             echo "BRANCH_NAME=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          fi
      - name: Get workflow id
        id: workflow-id
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          WORKFLOW_ID=$(gh api /repos/${{ github.repository }}/actions/runs/${{ github.run_id }} | jq -r .workflow_id)
          echo "WORKFLOW_ID=$WORKFLOW_ID" >> $GITHUB_OUTPUT
          echo "Workflow id: ${WORKFLOW_ID}"
      - name: Get previous build status
        shell: bash
        id: last-run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          LAST_CREATED_AT_ISO=$(gh api --jq "[.workflow_runs[] | select(.conclusion == \"success\") | .created_at][0]" /repos/${{ github.repository }}/actions/workflows/${{ steps.workflow-id.outputs.WORKFLOW_ID }}/runs?status=completed&branch=${{ steps.branch-name.outputs.BRANCH_NAME }})
          LAST_CREATED_AT_UNIX=$(date -d "$LAST_CREATED_AT_ISO" +%s)
          echo "LAST_CREATED_AT_ISO=$LAST_CREATED_AT_ISO" >> $GITHUB_OUTPUT
          echo "LAST_CREATED_AT_UNIX=$LAST_CREATED_AT_UNIX" >> $GITHUB_OUTPUT
          echo "Previous build created at: $LAST_CREATED_AT_ISO"
  poll-log:
    runs-on: ubuntu-latest
    needs: check-last-run
    steps:
      - name: Check for required secrets
        run: |
          if [[ -z "${{ secrets.AEM_LIVE_ADMIN_TOKEN }}" ]]; then
            echo "::error::The AEM_LIVE_ADMIN_TOKEN secret is not configured. Please add this secret to your repository settings."
            exit 1
          fi
      - name: Get Logs
        id: get-logs
        run: |
          echo "Debug: Last run ISO: ${{ needs.check-last-run.outputs.last-run-iso }}"
          
          # URL encode the from parameter (using tr to remove newlines)
          FROM_PARAM=$(echo -n "${{ needs.check-last-run.outputs.last-run-iso }}" | tr -d '\n' | jq -sRr @uri)
          echo "Debug: URL encoded from parameter: $FROM_PARAM"
          
          # Construct and echo the full URL for debugging
          FULL_URL="https://admin.hlx.page/log/adobe/helix-website/main?from=$FROM_PARAM"
          echo "Debug: Full URL: $FULL_URL"
          
          # Make the API request
          RESPONSE=$(curl --http1.1 -s -w "\n%{http_code}" \
            -H "Authorization: token $(echo -n "${{ secrets.AEM_LIVE_ADMIN_TOKEN }}" | tr -d '\n')" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHub-Actions-Workflow" \
            "$FULL_URL")
          
          # Extract status code from last line
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
          # Extract response body (everything except the last line)
          BODY=$(echo "$RESPONSE" | sed '$ d')
          
          echo "Debug: HTTP Status: $HTTP_STATUS"
          
          # Check if status code is not 2xx
          if [[ $HTTP_STATUS -lt 200 ]] || [[ $HTTP_STATUS -gt 299 ]]; then
            echo "Error: API request failed with status $HTTP_STATUS"
            echo "Response body: $BODY"
            exit 1
          fi
          
          # Process the response if status was ok
          LOGS=$(echo "$BODY" | jq -R 'fromjson | .entries | sort_by(.timestamp) | map(select(.route == "live"))' | base64 -w 0)
          
          echo "Debug: LOGS value length: ${#LOGS}"
          echo "Debug: First few characters: ${LOGS:0:100}"
          echo "logs=$LOGS" >> $GITHUB_OUTPUT
      - name: Check for publishes
        id: check-publishes
        if: steps.get-logs.outputs.logs != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Debug: Checking if logs output is empty"
          echo "Debug: Output value length: ${#LOGS}"
          echo "Debug: First few characters: ${LOGS:0:100}"
          echo "Debug: Raw output value: '${{ steps.get-logs.outputs.logs }}'"
          
          if [ -z "${{ steps.get-logs.outputs.logs }}" ]; then
            echo "Debug: logs output is empty"
            exit 0
          fi
          
          echo '${{ steps.get-logs.outputs.logs }}' | base64 -d | jq -c '.[]' | while read -r log; do
            user=$(echo "$log" | jq -r '.user // "unknown"')
            status=$(echo "$log" | jq -r '.status')
            timestamp=$(echo "$log" | jq -r '.timestamp')
            
            # Get all paths (combine path and paths, filter out empty strings)
            paths=$(echo "$log" | jq -r '[ .path, (.paths[]?) ] | map(select(length > 0))[]')
            
            echo "$paths" | while read -r path; do
              payload=$(jq -n \
                --arg type "resource-published-native" \
                --arg path "$path" \
                --arg user "$user" \
                --arg timestamp "$timestamp" \
                --arg status "$status" \
                '{
                  event_type: $type,
                  client_payload: {
                    path: $path,
                    user: $user,
                    timestamp: $timestamp,
                    status: $status
                  }
                }')
              
              gh api \
                --method POST \
                --header "Accept: application/vnd.github.v3+json" \
                "/repos/${{ github.repository }}/dispatches" \
                --input - <<< "$payload"
            done
          done
